using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace DTask.Tests.Interceptors.Emit;

internal readonly struct ILGeneratorInterceptorsRenderer(StringBuilder source)
{
    public void Render(Dictionary<InterceptedMethodInfo, List<InvocationExpressionSyntax>> invocations)
    {
        AppendBaseline();

        foreach (var pair in invocations)
        {
            InterceptedMethodInfo methodInfo = pair.Key;

            source.AppendLine();
            AppendInterceptsLocationAttributes(pair.Value);

            switch (methodInfo.Kind)
            {
                case InterceptedMethodKind.Emit:
                    AppendEmitMethod(methodInfo.ArgumentType);
                    break;

                case InterceptedMethodKind.DefineLabel:
                    AppendDefineLabelMethod();
                    break;

                case InterceptedMethodKind.MarkLabel:
                    AppendMarkLabelMethod();
                    break;

                case InterceptedMethodKind.DeclareLocal:
                    AppendDeclareLocalMethod();
                    break;
            }
        }

        source.Append("""
            }
        }
        """);
    }

    private void AppendEmitMethod(ArgumentType argumentType)
    {
        if (argumentType is ArgumentType.None)
        {
            source.AppendLine("""
                     public static void Emit(this ILGenerator il, OpCode opcode)
                     {
                         _il.Value?.Emit(opcode);
                         il.Emit(opcode);
                     }
             """);

            return;
        }

        source.Append("""
                public static void Emit(this ILGenerator il, OpCode opcode, 
        """);
        source.Append(argumentType.ToSourceString());
        source.AppendLine("""
         arg)
                {
                    _il.Value?.Emit(opcode, arg);
                    il.Emit(opcode, arg);
                }
        """);
    }

    private void AppendDefineLabelMethod()
    {
        source.AppendLine("""
                  public static Label DefineLabel(this ILGenerator il)
                  {
                      _il.Value?.DefineLabel();
                      return il.DefineLabel();
                  }
          """);
    }

    private void AppendMarkLabelMethod()
    {
        source.AppendLine("""
                  public static void MarkLabel(this ILGenerator il, Label label)
                  {
                      _il.Value?.MarkLabel(label);
                      il.MarkLabel(label);
                  }
          """);
    }

    private void AppendDeclareLocalMethod()
    {
        source.AppendLine("""
                  public static LocalBuilder DeclareLocal(this ILGenerator il, Type type)
                  {
                      _il.Value?.DeclareLocal(type);
                      return il.DeclareLocal(type);
                  }
          """);
    }

    private void AppendBaseline()
    {
        source.Append("""
         // <auto-generated />

         namespace System.Runtime.CompilerServices
         {
         #pragma warning disable CS9113 // Parameter is unread.
             [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
             file sealed class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute { }
         #pragma warning restore CS9113 // Parameter is unread.
         }

         namespace DTasks.Generated.Emit
         {
             using System.Diagnostics;
             using System.Reflection;
             using System.Reflection.Emit;
             using System.Runtime.CompilerServices;

             public static class ILGeneratorInterceptors
             {
                 private static readonly ThreadLocal<ILGenerator> _il = new();
             
                 public static IDisposable InterceptCalls(this ILGenerator il)
                 {
                     Debug.Assert(_il.Value is null);
                     
                     _il.Value = il;
                     return new DisposeGenerator(il);
                 }
             
                 private class DisposeGenerator(ILGenerator il) : IDisposable
                 {
                     void IDisposable.Dispose()
                     {
                         Debug.Assert(ReferenceEquals(il, _il.Value));
                         
                         _il.Value = null;
                     }
                 }
         """);
        source.AppendLine();
    }

    private void AppendInterceptsLocationAttributes(List<InvocationExpressionSyntax> nodes)
    {
        foreach (InvocationExpressionSyntax node in nodes)
        {
            LinePosition position = ((MemberAccessExpressionSyntax)node.Expression).Name.GetLocation().GetLineSpan().StartLinePosition;

            source
              .Append("        [InterceptsLocationAttribute(@\"")
              .Append(node.SyntaxTree.FilePath)
              .Append("\", ")
              .Append(position.Line + 1)
              .Append(", ")
              .Append(position.Character + 1)
              .AppendLine(")]");
        }
    }
}
